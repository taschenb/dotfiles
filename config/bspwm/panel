#! /bin/sh

# Requirements: 
# * Lemonbar with XFT support (https://github.com/krypt-n/bar)
# * Font: Awesome font for icons (http://fortawesome.github.io/Font-Awesome/)
# * Music: mpd/mopidy and mpc
# * Mails: maildir (default ~/.mail)
# * Volumebar: needs some customization based on the hardware

# Recommended:
# * Font: Meslo LG S DZ patched (https://github.com/ryanoasis/nerd-fonts)

# Caution:
# * This script isn't very portable yet. If you want to use it, you need
#   to adjust some stuff for your hardware.
# * Be aware, that it is also not optimized in any way and has quite a few
#   events/s going on, that might affect your battery.
# * If you have any feedback or tips, please don't hesitate to contact me,
#   as I'm aware that there must be better ways to do these things


########################################################################
#                           Configuration
########################################################################
# Fonts used
PANEL_FONT_FAMILY="Meslo LG S DZ for Powerline:size=9"
PANEL_FONT_ICONS="Font Awesome:size=10.6"

PANEL_HEIGHT=15

PANEL_FIFO=/tmp/panel-fifo

MAIL_DIR=~/.mail

COLOR_FILE=~/.config/bspwm/panel_colors

ETHERNET_DEV=enp0s25
########################################################################


if [ $(pgrep -cx panel) -gt 1 ] ; then
	printf "%s\n" "The panel is already running." >&2
	exit 1
fi

trap 'trap - TERM; kill 0' INT TERM QUIT EXIT


# Set the panel width based on the resolution on the primary display
PANEL_WIDTH=$(xdpyinfo | awk '/dimensions/ {print $2}' | cut -d 'x' -f1)
PANEL_GEOMETRY="${PANEL_WIDTH}x${PANEL_HEIGHT}+0+0"

# Load Colors
if [ -f "$COLOR_FILE" ]; then
    . $COLOR_FILE
fi

# Create PANEL_FIFO
[ -e "$PANEL_FIFO" ] && rm "$PANEL_FIFO"
mkfifo "$PANEL_FIFO"

bspc subscribe > "$PANEL_FIFO" &

# Display and monitor battery status.
# Shutdown system if battery is low
panel_battery() {
    # Check if a battery is present
    if [ -f /sys/class/power_supply/BAT0/status ]; then
        bat_status=$(cat /sys/class/power_supply/BAT0/status)
        bat_perc=$(cat /sys/class/power_supply/BAT0/capacity)

        # Set the color of the battery icon accoring to its current percentage
        if [ $bat_perc -gt 50 ]; then
            bat_color="$COLOR_BATTERY_GREEN"
        elif [ $bat_perc -lt 15 ]; then
            bat_color="$COLOR_BATTERY_RED"
        else
            bat_color="$COLOR_BATTERY_ORANGE"
        fi

        # Show different icons for different states
        case "$bat_status" in
            "Charging") bat_msg=" $bat_perc%" ;;
            "Full")     bat_msg=" Fully Charged" ;;
            "Unknown")  bat_msg=" AC" ;;
            "Discharging")
                # Shutdown, if battery is low
                if [ $bat_perc -lt 3 ]; then
                    $(/usr/bin/poweroff)
                    bat_icon=""
                elif [ $bat_perc -lt 9 ]; then
                    bat_icon=""
                elif [ $bat_perc -lt 26 ]; then
                    bat_icon=""
                elif [ $bat_perc -lt 60 ]; then 
                    bat_icon=""
                elif [ $bat_perc -lt 85 ]; then 
                    bat_icon=""
                else
                    bat_icon=""
                fi
                bat_msg="$bat_icon $bat_perc %"
                ;;
        esac

        echo "$bat_color $bat_msg"
    fi
}

# Display date and time
panel_clock() {
    echo "$COLOR_CLOCK   $(date "+%a %d, %T")"
}

# Check .mail for new mails
# This requires a background script downloading mails
panel_mail() {
    mail_new=$(find $MAIL_DIR/*/I*/new -type f | wc -l)
    mail_cur=$(find $MAIL_DIR/*/I*/cur -type f | wc -l)
    mail_tot=$((mail_new+mail_cur))
    if [ $mail_new -eq 0 ];then
        mail_icon=""
    else
        mail_icon=""
    fi
    echo "$COLOR_MAIL  $mail_icon $mail_new/$mail_tot"
}

# Display mpd/mopidy current song
# Requires mpc 
panel_mpd() {
    mpd_status=$(mpc status 2>&1 | sed -n '2p' | awk '{ print $1}')

    case "$mpd_status" in
        "[paused]")  echo "$COLOR_MPD_PAUSE   $(mpc current)" ;;
        "[playing]") echo "$COLOR_MPD_PLAY  $(mpc current)" ;;
    esac
}

panel_tor() {
    echo ""
}

panel_vpn() {
    echo ""
}

# Check if ethernet/wifi is connected 
panel_network() {
    wifi_quality=$(cat /proc/net/wireless | awk 'END { print $3 }' | \
        sed 's/\.$//')

    # Fix percentage
    wifi_quality=$(($wifi_quality/7*10))

    # TODO: Autodetect devices
    eth_carrier=$(cat /sys/class/net/$ETHERNET_DEV/carrier)

    if [ $eth_carrier = 1 ]; then
        #
        echo "$COLOR_NETWORK_ETHERNET  "
    elif [ $wifi_quality != 0 ]; then
        if [ $wifi_quality -lt 35 ]; then
            echo "$COLOR_NETWORK_WIFI_BAD  "
        elif [ $wifi_quality -lt 70 ]; then
            echo "$COLOR_NETWORK_WIFI_OK  "
        else
            echo "$COLOR_NETWORK_WIFI_GOOD  "
        fi
    fi
}

# Get volume level and track if headphone is plugged in.
# The following is working for a thinkpad with a dockingstation and also
# support my specific USB sound card

# Create files in order to track changes in volume over multiple executions.
# If the volume is changed, the corresponding icon in the bar will extend to a
# volume bar for a few seconds
mkdir -p /tmp/panel_scripts/audio
chmod 700 /tmp/panel_scripts -R
echo "none" > /tmp/panel_scripts/audio/volume
audio_counter=0
echo "0" > /tmp/panel_scripts/audio/counter
panel_audio() {
    # Mute? Possible values on/off
    sound_card0=$(cat /proc/asound/cards | awk '/^ 0 / {print $4}')
    sound_card1=$(cat /proc/asound/cards | awk '/^ 1 / {print $4}')

    # Detect which card to use. Depending on whether or not the USB card was
    # present at boot time, the order changes 
    if [ "$sound_card0" = HDA-Intel ]; then
        sound_card_intel=0
    elif [ "$sound_card1" = HDA-Intel ]; then
        sound_card_intel=1
    # Since no intel soundcard is being found, we probably are on another
    # system. Take the first card here
    else
        sound_card_intel=0
    fi

    audio_status=$(amixer -c $sound_card_intel get Master | \
        awk 'END { gsub(/[\[\]]/, ""); print $6 }')

    # Current volume percentage
    audio_volume=$(amixer -c $sound_card_intel get Master | awk 'END { gsub(/[\[\]%]/, ""); print $4 }')
    # Detect if headphone is plugged in either the notebook or dockingstation
    headphone=$(amixer -c $sound_card_intel contents | \
        awk -F "=" '/Headphone Jack/ { getline;getline; print $2 }' | \
        sed -n '1p')
    headphone_docking=$(amixer -c $sound_card_intel contents | \
        awk -F "=" '/Headphone Jack/ { getline;getline; print $2 }' | \
        sed -n '2p')

    if [ "$headphone" = on ] || [ "$headphone_docking" = on ]; then
        icon=""
    else
        if [ $audio_volume -lt 25 ]; then
            icon=""
        elif [ $audio_volume -lt 51 ]; then
            icon=""
        else
            icon=""
        fi
    fi

    # If the usb card is connected add a usb icon
    if [ "$sound_card0" = USB-Audio ] || [ "$sound_card1" = USB-Audio ]; then
        icon=" "
        # Manually set audio_muted to on if usb is present
        audio_status="on"
    fi

    # Print a volume bar for $max_count seconds till the last change in volume
    # before truncating it to an icon again
    audio_volume_last=$(cat /tmp/panel_scripts/audio/volume)
    max_count=3
    if [ "$audio_volume" = "$audio_volume_last" ]; then
        audio_counter=$(cat /tmp/panel_scripts/audio/counter)

        if [ $audio_counter -lt $max_count ]; then
            audio_counter=$((audio_counter+1))
            echo $audio_counter > /tmp/panel_scripts/audio/counter
        fi
    else
        # Reset counter
        echo 0 > /tmp/panel_scripts/audio/counter
        # Save new audio volume
        echo "$audio_volume" > /tmp/panel_scripts/audio/volume
    fi
    # Print the volume bar
    if [ $audio_counter -lt $max_count ]; then
        if [ "$audio_status" = off ]; then
            icon="$COLOR_AUDIO_OFF  $icon "
        else
            icon="$COLOR_AUDIO_ON  $icon "
        fi
        case $audio_volume in
            100) echo "$icon" "——————————" ;;
            [0-9]) echo "$icon" "—$COLOR_AUDIO_LEFT—————————" ;;
            1*) echo "$icon" "——$COLOR_AUDIO_LEFT————————" ;;
            2*) echo "$icon" "———$COLOR_AUDIO_LEFT———————" ;;
            3*) echo "$icon" "————$COLOR_AUDIO_LEFT——————" ;;
            4*) echo "$icon" "—————$COLOR_AUDIO_LEFT—————" ;;
            5*) echo "$icon" "——————$COLOR_AUDIO_LEFT————" ;;
            6*) echo "$icon" "———————$COLOR_AUDIO_LEFT———" ;;
            7*) echo "$icon" "————————$COLOR_AUDIO_LEFT——" ;;
            8*) echo "$icon" "—————————$COLOR_AUDIO_LEFT—" ;;
            9*) echo "$icon" "——————————" ;;
        esac
    # Truncate
    else
        if [ "$audio_status" = off ]; then
            echo "$COLOR_AUDIO_OFF  $icon"
        else
            echo "$COLOR_AUDIO_ON  $icon"
        fi
    fi

}

# Combine everything
# Set to > 5 to initiate a full refresh of all parts
# Set initially to above 5 to trigger a refresh when starting the panel
update_counter=10
while true; do
    # Update the non time critical parts of the bar only every 5s
    if [ $update_counter -lt 5 ]; then
        update_counter=$((update_counter+1))
    else
        update_counter=0
        # Print MPD with it's own line, because it will be displayed in the
        # center of the panel and needs to be processed separately
        echo "s $(panel_mpd)" > "$PANEL_FIFO" &
        # Save everything else in a variable to print together with the part,
        # that's updating every second
        panel_battery_msg=$(panel_battery)
        panel_mail_msg=$(panel_mail)
        panel_network_msg=$(panel_network)
    fi

    # Output everything every second
    echo "S  $(panel_audio)  $panel_battery_msg $panel_network_msg \
$(panel_clock) $panel_mail_msg " > "$PANEL_FIFO" &
    sleep 1;
done &

# Pipe everything through panel_bar to lemonbar
cat "$PANEL_FIFO" | ~/.config/bspwm/panel_bar | lemonbar -g "$PANEL_GEOMETRY" \
    -f "$PANEL_FONT_ICONS" -f "$PANEL_FONT_FAMILY" -F "$COLOR_FOREGROUND" \
    -B "$COLOR_BACKGROUND" &

wait
