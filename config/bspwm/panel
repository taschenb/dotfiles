#! /bin/sh

# Requirements:
# * Lemonbar with XFT support (https://github.com/krypt-n/bar)
# * Font: Awesome font for icons (http://fortawesome.github.io/Font-Awesome/)
# * Music: mpd/mopidy and mpc
# * Mails: maildir (default ~/.mail)
# * Volumebar: needs some customization based on the hardware
# * WiFi: iwconfig to determine the ESSID

# Recommended:
# * Font: Meslo LG S DZ patched (https://github.com/ryanoasis/nerd-fonts)

# Caution:
# * This script isn't very portable yet. If you want to use it, you need
#   to adjust some stuff for your hardware.
# * Be aware, that it is also not optimized in any way and has quite a few
#   events/s going on, that might affect your battery.


########################################################################
#                           Configuration
########################################################################
# Fonts used
PANEL_FONT_FAMILY="Meslo LG S DZ for Powerline:size=9"
PANEL_FONT_ICONS="Font Awesome:size=10.6"

PANEL_HEIGHT=15

PANEL_FIFO=/tmp/panel-fifo
TMP_DIR=/tmp/panel_scripts/

MAIL_DIR=~/.mail

COLOR_FILE=~/.config/bspwm/panel_colors
ICON_FILE=~/.config/bspwm/panel_icons

MPD_HOSTS=(localhost raspberry)
########################################################################


if [ $(pgrep -cx panel) -gt 1 ] ; then
    printf "%s\n" "The panel is already running." >&2
    exit 1
fi

trap 'trap - TERM; kill 0' INT TERM QUIT EXIT


# Set the panel width based on the resolution on the primary display
PANEL_WIDTH=$(xdpyinfo | awk '/dimensions/ {print $2}' | cut -d 'x' -f1)
PANEL_GEOMETRY="${PANEL_WIDTH}x${PANEL_HEIGHT}+0+0"

# Load Colors
[ -f "$COLOR_FILE" ] && . $COLOR_FILE
# Load Icons
[ -f "$ICON_FILE" ] && . $ICON_FILE

# Create PANEL_FIFO
[ -e "$PANEL_FIFO" ] && rm "$PANEL_FIFO"
mkfifo "$PANEL_FIFO"

bspc subscribe > "$PANEL_FIFO" &


# Display and monitor battery status.
# Shutdown system if battery is low
panel_battery() {
    # Check if a battery is present
    if [ -f /sys/class/power_supply/BAT0/status ]; then
        BAT_SHUTDOWN_PERC=3

        bat_status=$(cat /sys/class/power_supply/BAT0/status)
        bat_perc=$(cat /sys/class/power_supply/BAT0/capacity)

        # Set the color of the battery icon accoring to its current percentage
        if [ $bat_perc -gt 50 ]; then
            bat_color="$COLOR_BATTERY_GREEN"
        elif [ $bat_perc -lt 15 ]; then
            bat_color="$COLOR_BATTERY_RED"
        else
            bat_color="$COLOR_BATTERY_ORANGE"
        fi

        # Show different icons for different states
        case "$bat_status" in
            "Charging" | "Full")
                bat_msg="$ICON_BATTERY_AC $bat_perc%"
                ;;
            "Unknown")
                bat_msg="$ICON_BATTERY_AC AC"
                ;;
            "Discharging")
                # Shutdown, if battery is low
                if [ $bat_perc -lt $BAT_SHUTDOWN_PERC ]; then
                    $(/usr/bin/poweroff)
                    bat_icon="$ICON_BATTERY_EMPTY"
                elif [ $bat_perc -lt 9 ]; then
                    bat_icon="$ICON_BATTERY_EMPTY"
                elif [ $bat_perc -lt 26 ]; then
                    bat_icon="$ICON_BATTERY_LOW"
                elif [ $bat_perc -lt 60 ]; then
                    bat_icon="$ICON_BATTERY_MED"
                elif [ $bat_perc -lt 85 ]; then
                    bat_icon="$ICON_BATTERY_HIGH"
                else
                    bat_icon="$ICON_BATTERY_FULL"
                fi

                bat_msg="$bat_icon $bat_perc %"
                ;;
        esac

        echo "$bat_color$ICON_DIVIDER $bat_msg"
    fi
}


# Display date and time
panel_clock() {
    echo "$COLOR_CLOCK $ICON_DIVIDER $ICON_CLOCK $(date "+%a %d, %T")"
}


# Check .mail for new mails
# This requires a background script downloading mails
panel_mail() {
    mail_new=$(find $MAIL_DIR/*/I*/new -type f | wc -l)
    mail_cur=$(find $MAIL_DIR/*/I*/cur -type f | wc -l)
    mail_tot=$((mail_new+mail_cur))
    if [ $mail_new -eq 0 ];then
        mail_icon="$ICON_MAIL_NO_NEW"
    else
        mail_icon="$ICON_MAIL_NEW"
    fi
    echo "$COLOR_MAIL $ICON_DIVIDER $mail_icon $mail_new/$mail_tot"
}


# Display mpd/mopidy the currently playing song following the $MPD_HOSTS as
# priorities.
# Is something playing on $MPD_HOSTS[0], display it, regardless of the status
# of $MPD_HOSTS[1]. If more than one daemon is available and paused without any
# other in playing-state, it doesn't matter to me which one is being displayed,
# since all could be resumed from this machine.
# Requires mpc
panel_mpd() {
    for host in ${MPD_HOSTS[@]}; do
        mpd_status=$(mpc -h $host status 2>&1 | awk 'NR==2 { print $1}')

        case "$mpd_status" in
            "[paused]")
                mpd_line="$COLOR_MPD_PAUSE$ICON_MUSIC $ICON_MUSIC_PAUSE  $(mpc -h $host current)" ;;
            "[playing]")
                mpd_line="$COLOR_MPD_PLAY$ICON_MUSIC  $(mpc -h $host current)"
                break
                ;;
        esac
    done
    echo $mpd_line
}


# Display when Tor service is running
# This only checks if the service if active. Nothing more.
panel_tor() {
    if [ -f /usr/bin/tor ]; then
        tor_service=$(systemctl is-active tor)

        if [ "$tor_service" = "active" ]; then
            echo "$COLOR_TOR $ICON_DIVIDER $ICON_TOR"
        fi
    fi
}


# Display the default network interface
# Ethernet: Just display a icon here.
# WiFi: - Display truncated ESSID, if iwconfig is installed.
#       - Hint the connection quality by color.
# VPN: - For a tun/tap device, check which configuration is active by going
#        through all /etc/openvpn/client/*.conf files and their corresponding
#        openvpn-cleint@*.service systemd services.
#      - Show the first 3 characters of the active *.conf filename
panel_network() {
    default_interface=$(ip route | awk 'NR==1 { print $5}')

    case $default_interface in
        eth* | enp*)
            echo "$COLOR_NETWORK_ETHERNET $ICON_DIVIDER $ICON_ETHERNET"
            ;;
        wlan* | wlp*)
            wifi_quality=$(cat /proc/net/wireless | awk 'END { print $3 }' | \
                sed 's/\.$//')
            # Fix percentage
            wifi_quality=$(($wifi_quality/7*10))

            if [ $wifi_quality != 0 ]; then
                if [ $wifi_quality -lt 35 ]; then
                    wifi_color="$COLOR_NETWORK_WIFI_BAD"
                elif [ $wifi_quality -lt 70 ]; then
                    wifi_color="$COLOR_NETWORK_WIFI_OK"
                else
                    wifi_color="$COLOR_NETWORK_WIFI_GOOD"
                fi

                if which iwconfig > /dev/null 2>&1; then
                    essid_max_length=12

                    essid=$(iwconfig 2>/dev/null | sed -n '1p' | cut -f2 -d\")
                    essid=${essid::${essid_max_length}}
                fi

                echo "$wifi_color $ICON_DIVIDER $ICON_WIFI $essid"
            fi
            ;;
        tun* | tap*)
            for config in /etc/openvpn/client/*.conf; do
                connection_name=$(basename $config .conf)

                service="openvpn-client@$connection_name.service"

                if [ $(systemctl is-active $service) = "active" ]; then
                    server=${connection_name::3}
                fi
            done

            echo "$COLOR_VPN $ICON_DIVIDER $ICON_VPN $server"
            ;;
    esac
}


# Get volume level and track if headphone is plugged in.
# The following is working for a thinkpad with a dockingstation and also
# support my specific USB sound card

# Create files in order to track changes in volume over multiple executions.
# If the volume is changed, the corresponding icon in the bar will extend to a
# volume bar for a few seconds
mkdir -p $TMP_DIR/audio
chmod 700 $TMP_DIR -R
echo "none" > $TMP_DIR/audio/volume
audio_counter=0
echo "0" > $TMP_DIR/audio/counter
panel_audio() {
    # Mute? Possible values on/off
    sound_card0=$(cat /proc/asound/cards | awk '/^ 0 / {print $4}')
    sound_card1=$(cat /proc/asound/cards | awk '/^ 1 / {print $4}')

    # Detect which card to use. Depending on whether or not the USB card was
    # present at boot time, the order changes
    if [ "$sound_card0" = HDA-Intel ]; then
        sound_card_intel=0
    elif [ "$sound_card1" = HDA-Intel ]; then
        sound_card_intel=1
    # Since no intel soundcard is being found, we probably are on another
    # system. Take the first card here
    else
        sound_card_intel=0
    fi

    audio_status=$(amixer -c $sound_card_intel get Master | \
        awk 'END { gsub(/[\[\]]/, ""); print $6 }')

    # Current volume percentage
    audio_volume=$(amixer -c $sound_card_intel get Master | awk 'END { gsub(/[\[\]%]/, ""); print $4 }')
    # Detect if headphone is plugged in either the notebook or dockingstation
    headphone=$(amixer -c $sound_card_intel contents | \
        awk -F "=" '/Headphone Jack/ { getline;getline; print $2 }' | \
        sed -n '1p')
    headphone_docking=$(amixer -c $sound_card_intel contents | \
        awk -F "=" '/Headphone Jack/ { getline;getline; print $2 }' | \
        sed -n '2p')

    if [ "$headphone" = on ] || [ "$headphone_docking" = on ]; then
        icon="$ICON_HEADPHONES"
    else
        if [ $audio_volume -lt 25 ]; then
            icon="$ICON_VOLUME_LOW"
        elif [ $audio_volume -lt 51 ]; then
            icon="$ICON_VOLUME_MED"
        else
            icon="$ICON_VOLUME_HIGH"
        fi
    fi

    # If the usb card is connected add a usb icon
    if [ "$sound_card0" = USB-Audio ] || [ "$sound_card1" = USB-Audio ]; then
        icon="$ICON_VOLUME_HIGH "
        # Manually set audio_muted to on if usb is present
        audio_status="on"
    fi

    # Print a volume bar for $max_count seconds till the last change in volume
    # before truncating it to an icon again
    audio_volume_last=$(cat $TMP_DIR/audio/volume)
    max_count=3
    if [ "$audio_volume" = "$audio_volume_last" ]; then
        audio_counter=$(cat $TMP_DIR/audio/counter)

        if [ $audio_counter -lt $max_count ]; then
            audio_counter=$((audio_counter+1))
            echo $audio_counter > $TMP_DIR/audio/counter
        fi
    else
        # Reset counter
        echo 0 > $TMP_DIR/audio/counter
        # Save new audio volume
        echo "$audio_volume" > $TMP_DIR/audio/volume
    fi
    # Print the volume bar
    if [ $audio_counter -lt $max_count ]; then
        if [ "$audio_status" = off ]; then
            icon="$COLOR_AUDIO_OFF $ICON_DIVIDER $icon "
        else
            icon="$COLOR_AUDIO_ON $ICON_DIVIDER $icon "
        fi
        case $audio_volume in
            100) echo "$icon" "——————————" ;;
            [0-9]) echo "$icon" "—$COLOR_AUDIO_LEFT—————————" ;;
            1*) echo "$icon" "——$COLOR_AUDIO_LEFT————————" ;;
            2*) echo "$icon" "———$COLOR_AUDIO_LEFT———————" ;;
            3*) echo "$icon" "————$COLOR_AUDIO_LEFT——————" ;;
            4*) echo "$icon" "—————$COLOR_AUDIO_LEFT—————" ;;
            5*) echo "$icon" "——————$COLOR_AUDIO_LEFT————" ;;
            6*) echo "$icon" "———————$COLOR_AUDIO_LEFT———" ;;
            7*) echo "$icon" "————————$COLOR_AUDIO_LEFT——" ;;
            8*) echo "$icon" "—————————$COLOR_AUDIO_LEFT—" ;;
            9*) echo "$icon" "——————————" ;;
        esac
    # Truncate
    else
        if [ "$audio_status" = off ]; then
            echo "$COLOR_AUDIO_OFF $ICON_DIVIDER $icon"
        else
            echo "$COLOR_AUDIO_ON $ICON_DIVIDER $icon"
        fi
    fi

}


# Combine everything
# Set to > 5 to initiate a full refresh of all parts
# Set initially to above 5 to trigger a refresh when starting the panel
update_counter=10
while true; do
    # Update the non time critical parts of the bar only every 5s
    if [ $update_counter -lt 5 ]; then
        update_counter=$((update_counter+1))
    else
        update_counter=0
        # Print MPD with it's own line, because it will be displayed in the
        # center of the panel and needs to be processed separately
        echo "s $(panel_mpd)" > "$PANEL_FIFO" &
        # Save everything else in a variable to print together with the part,
        # that's updating every second
        panel_battery_msg=$(panel_battery)
        panel_mail_msg=$(panel_mail)
        panel_network_msg=$(panel_network)
    fi

    # Output everything every second
    echo "S $(panel_xmpp) $(panel_tor) $(panel_audio)  $panel_battery_msg $panel_network_msg \
$(panel_clock) $panel_mail_msg " > "$PANEL_FIFO" &
    sleep 1;
done &

# Pipe everything through panel_bar to lemonbar
cat "$PANEL_FIFO" | ~/.config/bspwm/panel_bar | lemonbar -d -g "$PANEL_GEOMETRY" \
    -f "$PANEL_FONT_ICONS" -f "$PANEL_FONT_FAMILY" -F "$COLOR_FOREGROUND" \
    -B "$COLOR_BACKGROUND" &

wait
